
/******************************************************************************
*
* Copyright (C) 2016 Xilinx, Inc. All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*
*
******************************************************************************/
/*****************************************************************************/
/**
*
* @file xcsi2txss_intr_example.c
* @addtogroup csi2txss_v1_0
* @{
*
* This file contains a design example using XCsi2TxSs driver with interrupts.
* It notify which of the following interrupt is generated by a print message
* 	- Incorrect Lane Configuration
* 	- GSP FIFO Full
*	- Ulps State
*	- Line Buffer Full
*	- Unsupported/Reserved Data type
*	- Pixel Data underrun
*
* @note		This example requires an interrupt controller connected to the
*		processor and the MIPI CSI2Tx Subsystem in the system.
*
*		For this example to display output, the user need to implement
*		initialization of the system (Csi2TxSs_PlatformInit) and after
*		MIPI CSI2Tx subsystem start (XCsi2TxSs_Start) is complete,
*		implement configuration of the video stream source in order to
*		provide the MIPI CSI2Tx Subsystem HIP input.
*		The functions Csi2TxSs_PlatformInit and Csi2TxSs_StreamSrc are
*		declared and are left up to the user implement.
*
* <pre>
* MODIFICATION HISTORY:
*
* Ver Who Date     Changes
* --- --- -------- ------------------------------------------------------------
* 1.0 sss 08/02/16 Initial release
*     ms  01/23/17 Modified xil_printf statement in main function to
*                  ensure that "Successfully ran" and "Failed" strings are
*                  available in all examples. This is a fix for CR-965028.
* </pre>
*
******************************************************************************/

/***************************** Include Files *********************************/

#include "xcsi2txss.h"
#include "xil_printf.h"
#include "xparameters.h"
#include "xstatus.h"
#include "xv_tpg.h"
/************************** Constant Definitions *****************************/

/*
* The following constants map to the names of the hardware instances.
* They are only defined here such that a user can easily change all the
* needed device IDs in one place.
*/


/* The unique device ID of the MIPI CSI2Tx Subsystem instance to be used
 */
#define XCSI2TXSS_DEVICE_ID		XPAR_CSI2TXSS_0_DEVICE_ID

/***************** Macros (Inline Functions) Definitions *********************/


/**************************** Type Definitions *******************************/


/************************** Function Prototypes ******************************/

u32 Csi2TxSs_IntrExample(u32 DeviceId);
u32 Csi2TxSs_PlatformInit(void);

/************************** Variable Definitions *****************************/

XCsi2TxSs Csi2TxSsInst;	/* The MIPI CSI2Tx Subsystem instance.*/

XV_tpg_Config		*tpg_Config;

XV_tpg				tpg;

volatile u32 interrupt_counts;

/************************** Function Definitions *****************************/

/******************************************************************************/
/**
*
* For Microblaze we use an assembly loop that is roughly the same regardless of
* optimization level, although caches and memory access time can make the delay
* vary.  Just keep in mind that after resetting or updating the PHY modes,
* the PHY typically needs time to recover.
*
* @param	Number of seconds to sleep
*
* @return	None
*
* @note		None
*
******************************************************************************/

#ifndef TESTAPP_GEN
/*****************************************************************************/
/**
*
* This is the main function for XCsi2TxSs interrupt example. If the
* Csi2TxSs_IntrExample function which sets up the system succeeds, this function
* will wait for the interrupts. Once a connection event or pulse is detected,
* Csi2TxSs will TX device capabilities and re-start the subsystem.
*
* @param	None.
*
* @return
*		- XST_FAILURE if the interrupt example was unsuccessful.
*		- XST_SUCCESS if the interrupt example was successful.
*
******************************************************************************/
int main()
{
	int Status;

	xil_printf("-------------------------------------------\n\r");
	xil_printf("  MIPI CSI2Tx Subsystem interrupt example\n\r");
	xil_printf("-------------------------------------------\n\r");

	Status = Csi2TxSs_IntrExample(XCSI2TXSS_DEVICE_ID);
	if (Status != XST_SUCCESS) {
		xil_printf("MIPI CSI2Tx Subsystem interrupt example "
				"failed.");
		return XST_FAILURE;
	}

	xil_printf("Successfully ran MIPI CSI2Tx Subsystem interrupt example\n\r");

	return XST_SUCCESS;
}
#endif

/*****************************************************************************/
/**
*
* This function is the main entry point for the interrupt example using the
* XCsi2TxSs driver. This function will set up the system with interrupts
* handlers.
*
* @param	DeviceId is the unique device ID of the MIPI CSI2Tx
*		Subsystem core.
*
* @return
*		- XST_FAILURE if the system setup failed.
*		- XST_SUCCESS should never return since this function, if setup
*		  was successful, is blocking.
*
* @note		If system setup was successful, this function is blocking in
*		order to illustrate interrupt handling.
*
******************************************************************************/
u32 Csi2TxSs_IntrExample(u32 DeviceId)
{
	u32 Status;
	XCsi2TxSs_Config *ConfigPtr;
	u8 ActiveLanes;
	u32 IntrRequest = XCSI2TXSS_ISR_ALLINTR_MASK;
	u8 Exit_Count = 0;

	tpg_Config = XV_tpg_LookupConfig(XPAR_V_TPG_0_DEVICE_ID);

		if(tpg_Config == NULL)

		{

			xil_printf("ERR:: TPG device not found\r\n");

			return(XST_DEVICE_NOT_FOUND);

		}

		Status = XV_tpg_CfgInitialize(&tpg, tpg_Config, tpg_Config->BaseAddress);

		if(Status != XST_SUCCESS)

		{

			xil_printf("ERR:: TPG Initialization failed %d\r\n", Status);

			return(XST_FAILURE);

		}

	/* Do platform initialization in this function. This is hardware
	 * system specific. It is up to the user to implement this function.
	 */
	xil_printf("PlatformInit\n\r");
	Status = Csi2TxSs_PlatformInit();
	if (Status != XST_SUCCESS) {
		xil_printf("Platform init failed!\n\r");
	}
	xil_printf("Platform initialization done.\n\r");

	/* Obtain the device configuration for the MIPI CSI2Tx Subsystem */
	ConfigPtr = XCsi2TxSs_LookupConfig(DeviceId);
	if (!ConfigPtr) {
		return XST_FAILURE;
	}
	/* Copy the device configuration into the Csi2TxSsInst's Config
	 * structure. */
	Status = XCsi2TxSs_CfgInitialize(&Csi2TxSsInst, ConfigPtr,
					ConfigPtr->BaseAddr);
	if (Status != XST_SUCCESS) {
		xil_printf("CSI2TXSS config initialization "
		"failed.\n\r");
		return XST_FAILURE;
	}
	/* Dump the configuration */
	XCsi2TxSs_ReportCoreInfo(&Csi2TxSsInst);

	/* Reset the subsystem */
	XCsi2TxSs_Reset(&Csi2TxSsInst);

	/* Disable the subsystem till the camera
	 * and interrupts are configured
	 */
	XCsi2TxSs_Activate(&Csi2TxSsInst, XCSI2TX_DISABLE);

	/* Configure the subsystem for ActiveLanes and Interrupts
	 * The minimum value of ActiveLanes is 0 and max value is
	 * maximum lanes set in the design (max 3).
	 * The interrupt mask can be selected from the bitmasks in
	 * xcsi2txss_hw.h
	 */
	ActiveLanes = 2;
	IntrRequest = XCSI2TXSS_ISR_ALLINTR_MASK;
	Status = XCsi2TxSs_Configure(&Csi2TxSsInst, ActiveLanes, IntrRequest);
	if (Status == XST_FAILURE) {
		xil_printf("CSI2TXSS Configure failed. \n\r");
		return XST_FAILURE;
	}
	XCsi2TxSs_SetClkMode(&Csi2TxSsInst,1); //Set discon clk Mode
	XCsi2TxSs_LineGen(&Csi2TxSsInst,XCSI2TX_DISABLE); //generate no line packets



	XV_tpg_Set_height(&tpg, 720);

	XV_tpg_Set_width(&tpg, 1280);

	XV_tpg_Set_colorFormat(&tpg, 0);

	XV_tpg_Set_bckgndId(&tpg, XTPG_BKGND_DP_COLOR_SQUARE);

	XV_tpg_Set_ovrlayId(&tpg, 0);

	XV_tpg_WriteReg(tpg_Config->BaseAddress, XV_TPG_CTRL_ADDR_AP_CTRL, 0x81);
	/* Enable the cores */
	XCsi2TxSs_Activate(&Csi2TxSsInst, XCSI2TX_ENABLE);

	while(1);

	return XST_SUCCESS;
}

/*****************************************************************************/
/**
*
* This function initialize required platform-specifc peripherals.
*
* @param	None.
*
* @return
*		- XST_SUCCESS if required peripherals are initialized and
*		configured successfully.
*		- XST_FAILURE, otherwise.
*
* @note		None.
*
******************************************************************************/
u32 Csi2TxSs_PlatformInit(void)
{
	/* User is responsible to setup platform specific initialization */

	return XST_SUCCESS;
}

